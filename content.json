{"posts":[{"title":"nodejs使用multer实现文件上传","text":"multer是一个用于上传文件的nodejs中间件，简化了图片等文件内容从前端上传到后端的过程，在使用期间踩了一些坑，记录一下。 安装 12$ npm install --save multer 基本用法：在前端html文件里： 123456&lt;form action=&quot;/images&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; id=&quot;form&quot;&gt; &lt;input type=&quot;file&quot; id =&quot;image-input&quot; name=&quot;imagefile&quot; class=&quot;btn&quot; multiple = &quot;multiple&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; 在后端js文件里 12345678910111213141516171819const multer = require('multer')const upload = multer({ dest: 'uploads/' })//这个是储存文件的地址，会在dest创建个文件夹router.post('/images', upload.single('imagefile'), function (req, res, next) { if (!req.file) { console.log(&quot;No file received&quot;); return res.send({ success: false }); } else { console.log('file received'); return res.send({ success: true }) }}) 其中特别要注意的是 enctype后面一定是”multipart/form-data” 如果允许上传多个文件（.array()或.fields()），确保上传的文件数不超过maxCount值。 这个input里的name和upload.single(‘name’)一定是一样的，在使用formdata时，name是: 1formdata.append(name,file) 跟前面的name对应 在自己的sumbitbutton触发事件里 12let form = document.getElementById(&quot;form&quot;)form.submit()//调用表单的提交function 试验一下：{“success”:true} 提交表单跳转解决方法：通过一个隐藏的 iframe 实现，form 表单的 target 设置为 iframe 的 name 名称，form 提交目标位当前页面 iframe 则不会刷新页面 1234&lt;form action=&quot;/url.do&quot; method=&quot;post&quot; target=&quot;targetIfr&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/form&gt; &lt;iframe name=&quot;targetIfr&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt; 父级页面获取iframe页面中的元素对象（关键contentWindow）：document.getElementById(iframe的id).contentWindow.document.getElementById(iframe页面元素id) iframe页面获取父级页面的元素对象（关键window.parent）：window.parent.document.getElementById(父级页面的元素id)","link":"/2022/12/07/nodejs%E4%BD%BF%E7%94%A8multer%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"},{"title":"我的奋斗","text":"一日之计在于晨 Welcome to my homepage, where I will write something.欢迎来到我的主页，这里我会写一些有用的东西:grin: 我的github","link":"/2022/12/02/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/"},{"title":"python从零构建哈希表","text":"Collision resolution techniques can be broken into two classes: open hashing (also called separate chaining) and closed hashing (also called open addressing). 了解开放式哈希之前需要了解： 开放式哈希与开放式寻址（封闭散列）是相反的东西 两者之间的区别与冲突是否存储在表外有关（开放式哈希)，或者冲突是否导致将其中一条记录存储在表中的另一个槽中（闭合散列，例如哈希桶）。 开放式哈希即分离链接指的是：当多个元素被散列到同一个槽索引中时，这些元素被插入到一个称为链的单链表中。 优点： 不会被填满 对哈希函数不敏感 缺点： 浪费空间 链太长的情况下，最坏搜索时间为 O(n) 存储链的数据结构：(python的列表) 搜索：O(l) 其中 l = 数组长度 删除：O(l) 插入：O(l) 这里我自己写个链表类，用List也可以，实现更简单更高效。 基本实现：先定义一个链表类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Node: def __init__(self,elem,next=None): self.elem = elem self.next = nextclass LinkedList: def __init__(self): self.count = 0 self.head = Node(None) self.tail = Node(None) self.head.next = self.tail self.tail.next = None def append(self,value): n=Node(value) h=self.head.next if self.head.next == self.tail: self.head.next = n n.next=self.tail else: while(h.next != self.tail): h=h.next h.next = n n.next = self.tail self.count+=1 def print(self): p=self.head.next while p !=self.tail: print(p.elem,end=&quot;&quot;) p=p.next if p!=self.tail: print(&quot; -&gt; &quot;,end=&quot;&quot;) print(&quot;&quot;) def insert(self,elem,index): n=Node(elem) p=self.head for i in range(0,index): if p == self.tail: return False p=p.next i = p.next p.next = n n.next = i self.count+=1 def index_to_value(self,index): p=self.head for i in range(0,index+1): if p == self.tail: return False p=p.next return p.elem def value_to_index(self,value): p=self.head for i in range(self.count+1): if p.elem == value: return i p=p.next return False def delete(self,index): obj=None nex=None if self.count == 0: return False p=self.head for i in range(0,index): if p == self.tail: return False p=p.next obj=p.next nex=obj.next p.next=nex self.count-=1 之后定义哈希表的函数 1234567891011121314151617181920212223242526272829303132333435def djb2(s): s=str(s) hash = 5381 for x in s: hash = (( hash &lt;&lt; 5) + hash) + ord(x) return (hash &amp; 0xFFFFFFFF) % len(HashTable)def display_hash(hashTable): for i in range(0,len(hashTable)): print(&quot;Link&quot;+str(i)+&quot;:&quot;,end=&quot; &quot;) hashTable[i].print()def insert(hashtable, value): hash_key = djb2(value) hashtable[hash_key].append(value)def delete(hashtable,value): hash_key = djb2(value) index=hashtable[hash_key].value_to_index(value) if index!= False: hashtable[hash_key].delete(index-1) else: print(&quot;value not found.&quot;)def search(hashtable,value): hash_key = djb2(value) if(hashtable[hash_key].value_to_index(value)==False): return 0 else: return &quot;Link&quot;+str(hash_key)+&quot;[&quot;+str(hashtable[hash_key].value_to_index(value)-1)+&quot;]&quot;def creat_list(n): hashTable=[] for i in range(n): L=LinkedList() hashTable.append(L) return hashTable 一个好的哈希函数满足： 抗碰撞性，尽量避免冲突 抗篡改性，只要改动一个字节，其哈希值也会很大不同 查找效率 这里我使用了一个叫djb2的哈希函数它对每个字符： 将5381都乘33然后将当前字符的ASCLL值添加进去 遍历整个字符数字后返回hash 输入 12345678910111213141516HashTable = creat_list(3)insert(HashTable, 12)insert(HashTable, 'hashtable')insert(HashTable, 1234)insert(HashTable, 4328989)insert(HashTable, 'BM40A1500')insert(HashTable, -12456)insert(HashTable, 'aaaabbbbbcccc')display_hash(HashTable)print(search(HashTable,-12456))print(search(HashTable,'hashtable'))print(search(HashTable,'aaaabbbbbcccc'))delete(HashTable,&quot;BM40A1500&quot;)delete(HashTable,1234)delete(HashTable,&quot;aaaabbbbbcccc&quot;)display_hash(HashTable) 输出: 123456789Link0: hashtable -&gt; 1234 -&gt; aaaabbbbbccccLink1: 4328989Link2: 12 -&gt; BM40A1500 -&gt; -12456Link2[2]Link0[0]Link0[2]Link0: hashtableLink1: 4328989Link2: 12 -&gt; -12456","link":"/2022/12/03/python%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"90 lines of code to creat FPS game AI aimbot","text":"This Christmas holiday, I was very bored, no homework and no learning tasks, so I spent some time studying computer vision. I heard a long time ago that someone implemented aimbot in fps with AI, so I also want to try to do something like that. I used yolov5 in this little project because it’s really easy to learn and powerful enough. To complete this aimbot, the steps are follows: Capture the current screen shot Process this screen shot to make the indentification process more efficient Get the identification result and get the screen coordinate position of the enemy Convert coordinate position into relative displacement distance Dynamically correct the displacement through pid algorithm Move the mouse according to the calculated displacement. First define the window to be captured. 1234567891011121314151617181920212223screen_x, screen_y = 2560,1440window_x,window_y= 350,350#find the screen centerscreen_x_center = screen_x / 2screen_y_center = screen_y / 2#(edge_x,edge_y) is the left vertex coordinate of the screen to be captured.edge_x = screen_x_center - window_x / 2edge_y = screen_y_center - window_y / 2grab_window= (int(screen_x / 2 - window_x / 2),int(screen_y / 2 - window_y / 2),#int(screen_x / 2 + window_x / 2),int(screen_y / 2 + window_y / 2))#Define the range of aim, so that we won't aim too far at the enemy.aim_x = 200 # aim widthaim_x_left = int(screen_x_center - aim_x / 2)aim_x_right = int(screen_x_center + aim_x / 2)aim_y = 350 # aim widthaim_y_up = int(screen_y_center - aim_y / 2 - 10)aim_y_down = int(screen_y_center + aim_y / 2 - 10) Define a PID class to correct the aim system(because enemy is moving). The PID controller is a common control algorithm that aims to control a system by continuously calculating an error value as the difference between a desired set point and a measured process variable (PV) and applying a correction based on proportional, integral, and derivative terms (P, I, and D respectively). 123456789101112131415161718192021222324252627class PID: def __init__(self, dt, max, min, p, i, d): self.dt = dt self.max = max self.min = min self.Kp = p self.Ki = i self.Kd = d self.integral = 0 self.pre_error = 0 def calculate(self, setPoint, pv): error = setPoint - pv Pout = self.Kp * error self.integral += error * self.dt Iout = self.Ki * self.integral derivative = (error - self.pre_error) / self.dt Dout = self.Kd * derivative output = Pout + Iout + Dout if (output &gt; self.max): output = self.max elif (output &lt; self.min): output = self.min self.pre_error = error return output Now capture the screen image and send it to yolov5 arter processing 123456789101112131415161718192021222324252627282930313233while True: # Capture the screen using OpenCV screen = cv2.cvtColor(np.array(ImageGrab.grab(grab_window)), cv2.COLOR_BGR2RGB) # Run object detection on the screen predictions = model(screen) df=predictions.pandas().xyxy[0].sort_values('confidence',ascending=False)try: data=df[df['name'] == 'person'].iloc[0].to_dict() xmin=data['xmin'] ymin=data['ymin'] xmax=data['xmax'] ymax=data['ymax'] xyxy=np.array([xmin,ymin,xmax,ymax]) target_xywh = xyxy2xywh(xyxy) target_xywh_x = target_xywh[0] + edge_x target_xywh_y = target_xywh[1] + edge_y except IndexError: continue else: if aim_x_left &lt; target_xywh_x &lt; aim_x_right and aim_y_up &lt; target_xywh_y &lt; aim_y_down: #Aiming condition final_x = target_xywh_x - screen_x_center + 0.25 * target_xywh[3] final_y = target_xywh_y - screen_y_center + 0.30 * target_xywh[3] pid_x = int(pid.calculate(final_x, 0)) pid_y = int(pid.calculate(final_y, 0)) aim_mouse = win32api.GetAsyncKeyState(win32con.VK_LBUTTON) if(aim_mouse): move_mouse(int(pid_x),int(pid_y)) #Stop aiming stop_mouse = win32api.GetAsyncKeyState(win32con.VK_RBUTTON) if(stop_mouse): print(&quot;stop&quot;) break","link":"/2022/12/24/90-lines-of-code-to-creat-fps-game-AI-aimbot/"},{"title":"DSA exam review","text":"Topic-oriented reviewTopic distributionweek 1 introductionADT：An abstract data type (ADT) is the specification of a data type within some language, independent of an implementation. The interface for the ADT is defined in terms of a type and a set of operations on that type. The behavior of each operation is determined by its inputs and outputs. An ADT does not specify how the data type is implemented. The sparse matrix refers to a large, two-dimensional array that stores only a relatively few non-zero values. data structure often refers to data stored in a computer’s main memory. file structure often refers to the organization of data on peripheral storage, such as a disk drive or CD. An algorithm has the following properties: It is composed of a series of concrete steps The output must be correct. Amount of steps must be finite and steps must be doable in a finite amount of time. It has to be aways clear which step comes next when performing the algorithm. When selecting a data structure to solve a problem, you should follow these steps： Analyze your problem to determine the basic operations that must be supported. Quantify the resource constraints for each operation. Select the data structure that best meets these requirements. week 2 Algorithm analysisgrowth rate：In algorithm analysis, the rate at which the cost of the algorithm grows as the size of its input grows. upper bound：In algorithm analysis, a growth rate that is always greater than or equal to the growth rate of the algorithm in question.O() lower bound：Inalgorithm analysis, a growth rate that is always less than or equal to the growth rate of the algorithm in question.Ω() constant running time：The cost of a function whose running time is not related to its input size. In Theta notation, this is traditionally written as Θ(1). asymptotic analysis：A method for estimating the efficiency of an algorithm or computer program by identifying its growth rate. week 3 Lists,queue,stackslinked list：An implementation for the list ADT that uses dynamic allocation of link nodes to store the list elements. stack：The stack is a list-like structure in which elements may be inserted or removed from only one end.【LIFO】 quene：A list-like structure in which elements are inserted only at one end, and removed only from the other one end.【FIFO】 binary search：A standard recursive algorithm for finding the record with a given search key value within a sorted list. It runs in O(logn)time. At each step, look at the middle of the current sublist, and throw away the half of the records whose keys are either too small or too large. Managing network printer tasks (in which order the tasks are printed?): Queue The back operation in a web browser: Stack week 4 HashingHashing：Hashing is a method for storing and retrieving records from a database. It lets you insert, delete, and search for records based on a search key value. hash function：converts a key value to a position in the hash table. hash table：The data structure (usually an array) that stores data records for lookup using hashing. open hash system：A hash system where multiple records might be associated with the same slot of a hash table. Typically this is done using a linked list to store the records. closed hash system：A hash system where all records are stored in slots of the hash table.The simplest approach to collision resolution is simply to move down the table from the home slot until a free slot is found. This is known as linear probing. open vs close：Open hashing (also known as separate chaining) is a method in which each slot in the hash table is a linked list. When a collision occurs, the new element is simply added to the end of the list for that slot. Open hashing is relatively easy to implement and can handle a large number of collisions, but it can be slower than closed hashing due to the need to traverse the linked list to find a particular element. Closed hashing (also known as open addressing) is a method in which each slot in the hash table can hold only one element. When a collision occurs, the hash function is used to compute an alternate location for the new element. This process continues until an empty slot is found. Closed hashing is faster than open hashing for small hash tables, but can become very slow and inefficient when the table becomes too full, and it may require dynamic resizing to accommodate more elements. In general, the choice of open vs. closed hashing depends on the specific use case and performance requirements of the application. If the number of elements to be stored is large and collisions are frequent, open hashing may be a better choice. If the number of elements is small and the hash function is well-designed, closed hashing may provide faster access times. week 5 Binary treesRecursion：An algorithm (or a function in a computer program) is recursive if it invokes itself to do part of its work. In general, a recursive algorithm must have two parts: The base case, which handles a simple input that can be solved without resorting to a recursive call The recursive part which contains one or more recursive calls to the algorithm. In every recursive call, the parameters must be in some sense “closer” to the base case than those of the original call. binary tree：A finite set of nodes which is either empty, or else has a root node together two binary trees, called the left and right subtrees, which are disjoint from each other and from the root. full vs complete：The tree of Figure 5.3(a) is full but not complete while the tree of Figure 5.3(b) is complete but not full. recursive data structure：is a data structure that is partially composed of smaller or simpler instances of the same data structure. Preorder Traversal：visit any given node before we visit its children. Postorder Traversal：visit each node only after we visit its children (and their subtrees). Inorder Traversal：first visits the left child (including its entire subtree), then visits the node, and finally visits the right child (including its entire subtree). The binary search tree makes use of this traversal to print all nodes in ascending order of value. binary search tree：A binary tree that imposes the following constraint on its node values: The search key value for any node A must be greater than the (key) values for all nodes in the left subtree of A, and less than the key values for all nodes in the right subtree of A. Some convention must be adopted if multiple nodes with the same key value are permitted, typically these are required to be in the right subtree. depth：The depth of a node M in a tree is the length of the path from the root of the tree to M. height：The height of a tree is one more than the depth of the deepest node in the tree. Properties of the binary tree：What is smallest possible height to a binary tree which has 12 nodes (number of steps from root to the most distant leaf node)：3 week 6 Balanced trees and heapsbalanced binary tree：binary tree in when the difference between the height of the left subtree and right subtree is not more than m, where m is usually equal to 1. 2-3 tree：A specialized form of the tree structure where each internal node has either 2 children or 3 children. Key values are ordered to maintain the binary search tree property. The 2-3 tree is always height balanced, and its insert, search, and remove operations all have Θ(logn) cost.2-3 树可以以相对较低的成本保持高度平衡AVL Tree：A variant implementation for the BST, which differs from the standard BST in that it uses modified insert and remove methods in order to keep the tree balanced. Similar to a Splay Tree in that it uses the concept of rotations in the insert and remove operations. advantage：AVL trees have a relatively low branching factor, which means that they use memory efficiently. They are also easy to implement and maintain, and can be used for a wide range of applications. Red-black tree：each node stores an extra bit representing “red” and “black”, which helps to keep the tree balanced during insertions and deletions.Red-black trees are simpler to implement than AVL trees and require fewer rotations, making them faster in practice. advantage：B-trees are optimized for disk access, which makes them ideal for use in databases and file systems. They can store a large amount of data efficiently and can be used to perform range queries quickly. BST and hashing：Balanced search trees are often preferred over hashing when the order of the data is important, as they maintain a sorted order. They can be used in a wide range of applications, including databases, file systems, and compilers. Hashing is preferred when the order of the data is not important and when fast access to a large number of elements is required. Hashing can be used in applications such as hash tables, bloom filters, and cryptography. Heaps：A heap is defined by two properties. First, it is a complete binary tree, so heaps are nearly always implemented using the array representation for complete binary trees. Second, the values stored in a heap are partially ordered. This means that there is a relationship between the value stored at any node and the values of its children. There are two variants of the heap, depending on the definition of this relationship. max heap has the property that every node stores a value that is greater than or equal to the value of either of its children. Because the root has a value greater than or equal to its children, which in turn have values greater than or equal to their children, the root stores the maximum of all values in the tree. min heap has the property that every node stores a value that is less than or equal to that of its children. Because the root has a value less than or equal to its children, which in turn have values less than or equal to their children, the root stores the minimum of all values in the tree. Priority Queues：a collection of objects is organized by importance or priority week 7,8 Algorithm design principlesThe greedy approach：making the locally optimal choice at each step with the hope of finding a global optimum. Θ(NlogN) Divide and conquer：breaking down a problem into smaller subproblems, solving each subproblem independently, and then combining the solutions to solve the original problem. Merge sort： Worst Case Time Complexity [ Big-O ]: O(n*log n) Best Case Time Complexity [Big-omega]: O(n*log n) Average Time Complexity [Big-theta]: O(n*log n) Space Complexity: O(n) need addittional space quick sort Worst Case Time Complexity [ Big-O ]: O(n^2) Best Case Time Complexity [Big-omega]: O(n*log n) Average Time Complexity [Big-theta]: O(n*log n) Space Complexity: O(n) Binary search Backtracking：systematically exploring all possible solutions to a problem by incrementally building a solution and then backtracking when the solution cannot be completed. N-Queens Problem Traveling Salesman Problem Dynamic programming：broken down into sub-problems, the results are saved, and then the sub-problems are optimized to find the overall solution Computing Fibonacci Numbers The Knapsack Problem Probabilistic algorithms: Las Vegas Algorithms: We always find the maximum value, and “usually” we find it fast. Such algorithms have a guaranteed result, but do not guarantee fast running time. Monte Carlo Algorithms: We find the maximum value fast, or we don’t get an answer at all (but fast). While such algorithms have good running time, their result is not guaranteed. week 9,10 Graphs Dijkstra’s algorithm Prim’s Algorithmdense Kruskal’s Algorithmsparse Exam-oriented review1.Terminologya)ADTb)stackquenelistc)Binary heapd)Closed Hashinge)Divide-and-conquerf)Dynamic Programming 2.Bin packing problema)design principleb)Does the algorithm always produce the optimal solution?c)running time(complexity) of the algorithm","link":"/2023/02/25/DSA-exam-review/"}],"tags":[{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"sb","slug":"sb","link":"/tags/sb/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"AI","slug":"AI","link":"/tags/AI/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"hobby","slug":"hobby","link":"/categories/hobby/"}],"pages":[]}
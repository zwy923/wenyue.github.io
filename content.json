{"posts":[{"title":"nodejs使用multer实现文件上传","text":"multer是一个用于上传文件的nodejs中间件，简化了图片等文件内容从前端上传到后端的过程，在使用期间踩了一些坑，记录一下。 安装 12$ npm install --save multer 基本用法：在前端html文件里： 123456&lt;form action=&quot;/images&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot; id=&quot;form&quot;&gt; &lt;input type=&quot;file&quot; id =&quot;image-input&quot; name=&quot;imagefile&quot; class=&quot;btn&quot; multiple = &quot;multiple&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;/&gt; &lt;/form&gt; 在后端js文件里 12345678910111213141516171819const multer = require('multer')const upload = multer({ dest: 'uploads/' })//这个是储存文件的地址，会在dest创建个文件夹router.post('/images', upload.single('imagefile'), function (req, res, next) { if (!req.file) { console.log(&quot;No file received&quot;); return res.send({ success: false }); } else { console.log('file received'); return res.send({ success: true }) }}) 其中特别要注意的是 enctype后面一定是”multipart/form-data” 如果允许上传多个文件（.array()或.fields()），确保上传的文件数不超过maxCount值。 这个input里的name和upload.single(‘name’)一定是一样的，在使用formdata时，name是: 1formdata.append(name,file) 跟前面的name对应 在自己的sumbitbutton触发事件里 12let form = document.getElementById(&quot;form&quot;)form.submit()//调用表单的提交function 试验一下：{“success”:true} 提交表单跳转解决方法：通过一个隐藏的 iframe 实现，form 表单的 target 设置为 iframe 的 name 名称，form 提交目标位当前页面 iframe 则不会刷新页面 1234&lt;form action=&quot;/url.do&quot; method=&quot;post&quot; target=&quot;targetIfr&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;/form&gt; &lt;iframe name=&quot;targetIfr&quot; style=&quot;display:none&quot;&gt;&lt;/iframe&gt; 父级页面获取iframe页面中的元素对象（关键contentWindow）：document.getElementById(iframe的id).contentWindow.document.getElementById(iframe页面元素id) iframe页面获取父级页面的元素对象（关键window.parent）：window.parent.document.getElementById(父级页面的元素id)","link":"/2022/12/07/nodejs%E4%BD%BF%E7%94%A8multer%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"},{"title":"我的奋斗","text":"一日之计在于晨 Welcome to my homepage, where I will write something.欢迎来到我的主页，这里我会写一些有用的东西:grin: 我的github","link":"/2022/12/02/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/"},{"title":"python从零构建哈希表","text":"Collision resolution techniques can be broken into two classes: open hashing (also called separate chaining) and closed hashing (also called open addressing). 了解开放式哈希之前需要了解： 开放式哈希与开放式寻址（封闭散列）是相反的东西 两者之间的区别与冲突是否存储在表外有关（开放式哈希)，或者冲突是否导致将其中一条记录存储在表中的另一个槽中（闭合散列，例如哈希桶）。 开放式哈希即分离链接指的是：当多个元素被散列到同一个槽索引中时，这些元素被插入到一个称为链的单链表中。 优点： 不会被填满 对哈希函数不敏感 缺点： 浪费空间 链太长的情况下，最坏搜索时间为 O(n) 存储链的数据结构：(python的列表) 搜索：O(l) 其中 l = 数组长度 删除：O(l) 插入：O(l) 这里我自己写个链表类，用List也可以，实现更简单更高效。 基本实现：先定义一个链表类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Node: def __init__(self,elem,next=None): self.elem = elem self.next = nextclass LinkedList: def __init__(self): self.count = 0 self.head = Node(None) self.tail = Node(None) self.head.next = self.tail self.tail.next = None def append(self,value): n=Node(value) h=self.head.next if self.head.next == self.tail: self.head.next = n n.next=self.tail else: while(h.next != self.tail): h=h.next h.next = n n.next = self.tail self.count+=1 def print(self): p=self.head.next while p !=self.tail: print(p.elem,end=&quot;&quot;) p=p.next if p!=self.tail: print(&quot; -&gt; &quot;,end=&quot;&quot;) print(&quot;&quot;) def insert(self,elem,index): n=Node(elem) p=self.head for i in range(0,index): if p == self.tail: return False p=p.next i = p.next p.next = n n.next = i self.count+=1 def index_to_value(self,index): p=self.head for i in range(0,index+1): if p == self.tail: return False p=p.next return p.elem def value_to_index(self,value): p=self.head for i in range(self.count+1): if p.elem == value: return i p=p.next return False def delete(self,index): obj=None nex=None if self.count == 0: return False p=self.head for i in range(0,index): if p == self.tail: return False p=p.next obj=p.next nex=obj.next p.next=nex self.count-=1 之后定义哈希表的函数 1234567891011121314151617181920212223242526272829303132333435def djb2(s): s=str(s) hash = 5381 for x in s: hash = (( hash &lt;&lt; 5) + hash) + ord(x) return (hash &amp; 0xFFFFFFFF) % len(HashTable)def display_hash(hashTable): for i in range(0,len(hashTable)): print(&quot;Link&quot;+str(i)+&quot;:&quot;,end=&quot; &quot;) hashTable[i].print()def insert(hashtable, value): hash_key = djb2(value) hashtable[hash_key].append(value)def delete(hashtable,value): hash_key = djb2(value) index=hashtable[hash_key].value_to_index(value) if index!= False: hashtable[hash_key].delete(index-1) else: print(&quot;value not found.&quot;)def search(hashtable,value): hash_key = djb2(value) if(hashtable[hash_key].value_to_index(value)==False): return 0 else: return &quot;Link&quot;+str(hash_key)+&quot;[&quot;+str(hashtable[hash_key].value_to_index(value)-1)+&quot;]&quot;def creat_list(n): hashTable=[] for i in range(n): L=LinkedList() hashTable.append(L) return hashTable 一个好的哈希函数满足： 抗碰撞性，尽量避免冲突 抗篡改性，只要改动一个字节，其哈希值也会很大不同 查找效率 这里我使用了一个叫djb2的哈希函数它对每个字符： 将5381都乘33然后将当前字符的ASCLL值添加进去 遍历整个字符数字后返回hash 输入 12345678910111213141516HashTable = creat_list(3)insert(HashTable, 12)insert(HashTable, 'hashtable')insert(HashTable, 1234)insert(HashTable, 4328989)insert(HashTable, 'BM40A1500')insert(HashTable, -12456)insert(HashTable, 'aaaabbbbbcccc')display_hash(HashTable)print(search(HashTable,-12456))print(search(HashTable,'hashtable'))print(search(HashTable,'aaaabbbbbcccc'))delete(HashTable,&quot;BM40A1500&quot;)delete(HashTable,1234)delete(HashTable,&quot;aaaabbbbbcccc&quot;)display_hash(HashTable) 输出: 123456789Link0: hashtable -&gt; 1234 -&gt; aaaabbbbbccccLink1: 4328989Link2: 12 -&gt; BM40A1500 -&gt; -12456Link2[2]Link0[0]Link0[2]Link0: hashtableLink1: 4328989Link2: 12 -&gt; -12456","link":"/2022/12/03/python%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"title":"90 lines of code to creat FPS game AI aimbot","text":"This Christmas holiday, I was very bored, no homework and no learning tasks, so I spent some time studying computer vision. I heard a long time ago that someone implemented aimbot in fps with AI, so I also want to try to do something like that. I used yolov5 in this little project because it’s really easy to learn and powerful enough. To complete this aimbot, the steps are follows: Capture the current screen shot Process this screen shot to make the indentification process more efficient Get the identification result and get the screen coordinate position of the enemy Convert coordinate position into relative displacement distance Dynamically correct the displacement through pid algorithm Move the mouse according to the calculated displacement. First define the window to be captured. 1234567891011121314151617181920212223screen_x, screen_y = 2560,1440window_x,window_y= 350,350#find the screen centerscreen_x_center = screen_x / 2screen_y_center = screen_y / 2#(edge_x,edge_y) is the left vertex coordinate of the screen to be captured.edge_x = screen_x_center - window_x / 2edge_y = screen_y_center - window_y / 2grab_window= (int(screen_x / 2 - window_x / 2),int(screen_y / 2 - window_y / 2),#int(screen_x / 2 + window_x / 2),int(screen_y / 2 + window_y / 2))#Define the range of aim, so that we won't aim too far at the enemy.aim_x = 200 # aim widthaim_x_left = int(screen_x_center - aim_x / 2)aim_x_right = int(screen_x_center + aim_x / 2)aim_y = 350 # aim widthaim_y_up = int(screen_y_center - aim_y / 2 - 10)aim_y_down = int(screen_y_center + aim_y / 2 - 10) Define a PID class to correct the aim system(because enemy is moving). The PID controller is a common control algorithm that aims to control a system by continuously calculating an error value as the difference between a desired set point and a measured process variable (PV) and applying a correction based on proportional, integral, and derivative terms (P, I, and D respectively). 123456789101112131415161718192021222324252627class PID: def __init__(self, dt, max, min, p, i, d): self.dt = dt self.max = max self.min = min self.Kp = p self.Ki = i self.Kd = d self.integral = 0 self.pre_error = 0 def calculate(self, setPoint, pv): error = setPoint - pv Pout = self.Kp * error self.integral += error * self.dt Iout = self.Ki * self.integral derivative = (error - self.pre_error) / self.dt Dout = self.Kd * derivative output = Pout + Iout + Dout if (output &gt; self.max): output = self.max elif (output &lt; self.min): output = self.min self.pre_error = error return output Now capture the screen image and send it to yolov5 arter processing 123456789101112131415161718192021222324252627282930313233while True: # Capture the screen using OpenCV screen = cv2.cvtColor(np.array(ImageGrab.grab(grab_window)), cv2.COLOR_BGR2RGB) # Run object detection on the screen predictions = model(screen) df=predictions.pandas().xyxy[0].sort_values('confidence',ascending=False)try: data=df[df['name'] == 'person'].iloc[0].to_dict() xmin=data['xmin'] ymin=data['ymin'] xmax=data['xmax'] ymax=data['ymax'] xyxy=np.array([xmin,ymin,xmax,ymax]) target_xywh = xyxy2xywh(xyxy) target_xywh_x = target_xywh[0] + edge_x target_xywh_y = target_xywh[1] + edge_y except IndexError: continue else: if aim_x_left &lt; target_xywh_x &lt; aim_x_right and aim_y_up &lt; target_xywh_y &lt; aim_y_down: #Aiming condition final_x = target_xywh_x - screen_x_center + 0.25 * target_xywh[3] final_y = target_xywh_y - screen_y_center + 0.30 * target_xywh[3] pid_x = int(pid.calculate(final_x, 0)) pid_y = int(pid.calculate(final_y, 0)) aim_mouse = win32api.GetAsyncKeyState(win32con.VK_LBUTTON) if(aim_mouse): move_mouse(int(pid_x),int(pid_y)) #Stop aiming stop_mouse = win32api.GetAsyncKeyState(win32con.VK_RBUTTON) if(stop_mouse): print(&quot;stop&quot;) break","link":"/2022/12/24/90-lines-of-code-to-creat-fps-game-AI-aimbot/"}],"tags":[{"name":"backend","slug":"backend","link":"/tags/backend/"},{"name":"sb","slug":"sb","link":"/tags/sb/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"AI","slug":"AI","link":"/tags/AI/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"hobby","slug":"hobby","link":"/categories/hobby/"}],"pages":[]}
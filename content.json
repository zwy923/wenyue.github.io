{"posts":[{"title":"我的奋斗","text":"一年之计在于春。 突发奇想搞一个博客。Welcome to my homepage, where I will write something.欢迎来到我的主页，这里我会写一些有用的东西:grin: My github 1$ hexo new &quot;New Post&quot;","link":"/2022/12/03/%E6%88%91%E7%9A%84%E5%A5%8B%E6%96%97/"},{"title":"回溯算法和分支界定法和TSP","text":"回溯算法和分支界定的区别： 回溯效率高能求解，分支界定法只是优化 回溯解决全排列，N皇后问题，分支界定法解决背包问题和旅行商问题 回溯算法主要特点： 结束条件（什么时候完成一个排列） 能做什么选择 剪枝 回溯算法其本质是暴力解法","link":"/2022/12/03/%E5%88%86%E6%94%AF%E7%95%8C%E5%AE%9A%E6%B3%95%E5%92%8CTSP/"},{"title":"python构建开放哈希表(字符串哈希函数)","text":"Collision resolution techniques can be broken into two classes: open hashing (also called separate chaining) and closed hashing (also called open addressing). 了解开放式哈希之前需要了解： 开放式哈希与开放式寻址（封闭散列）是相反的东西 两者之间的区别与冲突是否存储在表外有关（开放式哈希)，或者冲突是否导致将其中一条记录存储在表中的另一个槽中（闭合散列，例如哈希桶）。 开放式哈希即分离链接指的是：当多个元素被散列到同一个槽索引中时，这些元素被插入到一个称为链的单链表中。 优点： 不会被填满 对哈希函数不敏感 缺点： 浪费空间 链太长的情况下，最坏搜索时间为 O(n) 存储链的数据结构：(python的列表) 搜索：O(l) 其中 l = 数组长度 删除：O(l) 插入：O(l) 这里我自己写个链表类，用List也可以，实现更简单更高效。 基本实现：先定义一个链表类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Node: def __init__(self,elem,next=None): self.elem = elem self.next = nextclass LinkedList: def __init__(self): self.count = 0 self.head = Node(None) self.tail = Node(None) self.head.next = self.tail self.tail.next = None def append(self,value): n=Node(value) h=self.head.next if self.head.next == self.tail: self.head.next = n n.next=self.tail else: while(h.next != self.tail): h=h.next h.next = n n.next = self.tail self.count+=1 def print(self): p=self.head.next while p !=self.tail: print(p.elem,end=&quot;&quot;) p=p.next if p!=self.tail: print(&quot; -&gt; &quot;,end=&quot;&quot;) print(&quot;&quot;) def insert(self,elem,index): n=Node(elem) p=self.head for i in range(0,index): if p == self.tail: return False p=p.next i = p.next p.next = n n.next = i self.count+=1 def index_to_value(self,index): p=self.head for i in range(0,index+1): if p == self.tail: return False p=p.next return p.elem def value_to_index(self,value): p=self.head for i in range(self.count+1): if p.elem == value: return i p=p.next return False def delete(self,index): obj=None nex=None if self.count == 0: return False p=self.head for i in range(0,index): if p == self.tail: return False p=p.next obj=p.next nex=obj.next p.next=nex self.count-=1 之后定义哈希表的函数 123456789101112131415161718192021222324252627282930313233343536def djb2(s): s=str(s) hash = 5381 for x in s: hash = (( hash &lt;&lt; 5) + hash) + ord(x) return (hash &amp; 0xFFFFFFFF) % len(HashTable)def display_hash(hashTable): for i in range(0,len(hashTable)): print(&quot;Link&quot;+str(i)+&quot;:&quot;,end=&quot; &quot;) hashTable[i].print()def insert(hashtable, value): hash_key = djb2(value) hashtable[hash_key].append(value)def delete(hashtable,value): hash_key = djb2(value) index=hashtable[hash_key].value_to_index(value) if index!= False: hashtable[hash_key].delete(index-1) else: print(&quot;value not found.&quot;)def search(hashtable,value): hash_key = djb2(value) if(hashtable[hash_key].value_to_index(value)==False): return 0 else: return &quot;Link&quot;+str(hash_key)+&quot;[&quot;+str(hashtable[hash_key].value_to_index(value)-1)+&quot;]&quot;def creat_list(n): hashTable=[] for i in range(n): L=LinkedList() hashTable.append(L) return hashTable 一个好的哈希函数满足： 抗碰撞性，尽量避免冲突 抗篡改性，只要改动一个字节，其哈希值也会很大不同 查找效率 这里我使用了一个叫djb2的哈希函数它对每个字符： 将5381都乘33然后将当前字符的ASCLL值添加进去 遍历整个字符数字后返回hash 输入 12345678910111213141516HashTable = creat_list(3)insert(HashTable, 12)insert(HashTable, 'hashtable')insert(HashTable, 1234)insert(HashTable, 4328989)insert(HashTable, 'BM40A1500')insert(HashTable, -12456)insert(HashTable, 'aaaabbbbbcccc')display_hash(HashTable)print(search(HashTable,-12456))print(search(HashTable,'hashtable'))print(search(HashTable,'aaaabbbbbcccc'))delete(HashTable,&quot;BM40A1500&quot;)delete(HashTable,1234)delete(HashTable,&quot;aaaabbbbbcccc&quot;)display_hash(HashTable) 输出： 123456789Link0: hashtable -&gt; 1234 -&gt; aaaabbbbbccccLink1: 4328989Link2: 12 -&gt; BM40A1500 -&gt; -12456Link2[2]Link0[0]Link0[2]Link0: hashtableLink1: 4328989Link2: 12 -&gt; -12456","link":"/2022/12/03/%E6%9E%84%E5%BB%BA%E5%BC%80%E6%94%BE%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"tags":[{"name":"sb","slug":"sb","link":"/tags/sb/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"}],"pages":[]}